Alright, so I'd say we've got a decent MVP right now.

So what needs to improve?

1) I would like a single batch file to run and output a .csv and a plot,
assuming the arduino program is already running. And have everything in a
single folder so it can be shared + run by others assuming they have
python 3.7. (libraries will be included)

- 2) Need to check the ranges of the PmodIA and provide software options
to adjust it (rfb, pga, v_pp)

4.5) create a board for resistors for testing, equivalent to electrode contacts

5) bring hemostats
6) need to order LEADED solder
7) 0 clearance snippers

1 - 8) need to prove that PmodIA provides good values, and expected ranges for
an RC circuit, at all frequencies, on board and compare when connected straight
to the PModIA

9) save calibration data... on EE prom or python?

10) resolve setup issue.. each time python script runs, setup() in arduino
is run <--- just live with this for now

11) create API for the arduino program so it can be triggered in software

12) create UI for the python... preferably visual

14) create error checking for upper and lower frequency range
14.5) integrate external clock

So, many things need to be improved the project from an MVP
to a useful tool. And for that it needs to become easier to use, from
the ground up. Building more features or correcting lower level functions
with higher level convolution will not be good. Also, let's work the
perspective that the arduino should be controlled by serial interface
to a python, and should provide an appropriate API.

...But I'm still conflicted. Because I really need to prove the impedance
values are reliable.

Now let's see... where was I.
I was working on converting some of the code to better work / interface to
the PModIA features, specifically a frequency sweep.
Let's start here, get a frequency sweep

Alright, so frequency sweep is working as expected for a resistor
Next, let's do it for a series RC, (still don't have inductors?), then how about
I clean up the lab, yeah?, and order stuff, remember, take care of
administrative stuff. It's important.

Alright, time to figure out this range ish, first need the api to do it

so... range wise... I tried to do it all at once and everything failed,
and I don't know exactly where it went wrong, after trying to trace
with print statements... so let's revert to rev_8, and range functionality to
rev_10 piece by piece
Now... what order to do things in, and how to check for completion?
1) pga_gain <--- this can be check by reading the register directly
2) v_pp_code <--- this can be check by reading the register directly
3) rfb <--- this can be checked by multimeter on output pin

So range switching seems to be fine... now, there's a LOT I could be doing
but I really need to focus on the deliverables, and ease of use / code
maintenance. That is, at some point I need to nail down my code format
for easier editing later. I need to do a multiplex sweep through at least one
range and find a way to show that data.

Then I need to add a second range which also means...
--> adding range switching
--> adding calibration for the different ranges...
    --> add facility to save calibration data
    --> at this point I'll probably do the linear calibration (imp & phase)
--> then I'd like to create some sort of interface so python can directly
control the device rather than go through the arduino..., well maybe not
that much, but some control would make life easier

So, what format to send the data in, I suppose first I should try it with
the switching. Switching looks fine

Okay, let's think through this
I have 96 lists, I want to collapse those into a 96 by x np.array,
then plotting is trivial, i'd like to do this for each time 96 are iterated
through, forget error checking for now. Need to update plot instead of
remaking each time

Let's make x axis frequency, and draw a new graph when frequencies re-start.
But... that's actually not priority. Priority is getting the feedback resistor
/ calibration value for a two point saved, on the PModIA
1) save calibration value
2) save calibration for two point calibration
3) do formal justification for resistance value

All right, let's think here. First, it'd be nice to simplify things
Like a lot. and let's troubleshoot in order
1) is something being written to EEPROM ?
2) what is being written to EEPROM ?
3) what address is it being written to ?
4) is something being read from EEPROM ?
5) what is being read from EEPROM ?
6) what address is it being read from ?

I'd like to get a handle on the code before going any further, and to
get some documentation going.
1) let's go through existing rev_13 code and organize it logically
2) then let's figure out how I'd like to document it
3) then let's add the remaining functionality of calibration
  - this should be on the arduino side of things? need to centralize
    memory management somehow
4) then let's create a
 - testing / calibration program
 - a readout program

Alright, let's keep plugging away
1) code is getting organized, I can always stop to better do this while
working today
2) do the documentation later
3) let's finish up the two point calibration, and the saving of data,
after that I think we're home free
4) then create separate calibration and measurement programs

So... I think a lot of my confusion comes with not knowing exactly the
paradigm that variables are handled and the order that functions are called...
so let's review this before going on any further
1) set range parameters
- this function assigns the arguments to object attributes
- it also contains the control register setting, so it can also be called
from the control register function and do it's thing. If these two functions
are separated, it can be confusing as to which does which
2) set sweep parameters
- sets all the parameters for a sweep
3) begin frequency sweep
- it sets the control registers to begin the sweep and waits till
registers are valid
4) Impedance (called by getImpedance) actually takes the values from
the R and I registers, finds it's magnitude, and converts with GF value
to return the impedance
5) Phase (called by getPhase) actually takes the R and I registers
to get it's phase. Does not do any adjustment... does the phase need a
calibration?

Alright, so I have nearly isolated the important functions for this
part of the work.
It's important to note the paradigm of assigning to attributes rather
than returning values. this is fine

I want one function to do the calculations for the gain factor
I want one function to do the calculation for the system phase
I want one function to do the sweep at a given frequency and impedance
then call the calculators

So, what all does calibrate need to do?
It needs to get a gf for each point, and then save them

Okay, so now need the test calibration script...
This should
1) assume it's been calibrated
2) accept an impedance value (hardcoded in arduino)
3) read the impedance over full frequency
4) read in scan to python
--> in python
4) append to a csv file, or just create a new file with impedance name... I
    like that better
5) then this should be done for multiple values and plots should be combined
--> enter 2nd python script

eventually arduino should listen to different commands... from the python,
so there will just be one script... this will be nice and much easier
to work with experimentally

Okay I'm flustered and lost on this phase calibration... let's take a break
and think through it step by step. Plan, get back to raw phase output, and go
from there. expecting to see a DC and a linear response

Alright, so now we've got to transition to the python side of things
I want it to read every frequency and output it... easy peazy
I really should have separated the PModIA code. I mean, I'm not concerned...
but it just doesn't make any sense, and long term it's definitely not ideal

okay... so things are looking shit
1) need to revamp connector so there is even distribution of pressure somehow
which I see no way of doing with current paradigm... so that sucks
2) need python to write to arduino... will be much easier to debug and control
with this feature
3) need to double check shorts on board... maybe easier with leaded solder
or with solder pasting whole thing

alright, so it appears i don't know what's going on...
I need a simple echo program between python and arduino to wrap my head around
what I'm looking for. what parties are at play. alright, we got a little shitty
trigger... good enough for now. I'm really getting to the point where
my knowledge is drastically slowing things down. need to step back and learn
the basics
